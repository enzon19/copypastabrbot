<!DOCTYPE html>
<html lang="pt">

<head>
	<meta charset="UTF-8">
	<title>Status do Buscapé Bot</title>
	<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/enzon19/copypastabrbot/main/resources/favicon_io/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/enzon19/copypastabrbot/main/resources/favicon_io/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/enzon19/copypastabrbot/main/resources/favicon_io/favicon-16x16.png">
	<link rel="manifest" href="https://raw.githubusercontent.com/enzon19/copypastabrbot/main/resources/favicon_io/site.webmanifest">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter&display=swap');
		@import url('https://fonts.googleapis.com/css2?family=Inter:wght@700&display=swap');

        body {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' version='1.1' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:svgjs='http://svgjs.com/svgjs' width='1920' height='1080' preserveAspectRatio='none' viewBox='0 0 1440 560'%3e%3cg mask='url(%26quot%3b%23SvgjsMask1054%26quot%3b)' fill='none'%3e%3crect width='1440' height='560' x='0' y='0' fill='rgba(43%2c 85%2c 12%2c 1)'%3e%3c/rect%3e%3cpath d='M0%2c424.448C90.455%2c439.814%2c194.363%2c472.024%2c269.634%2c419.559C345.011%2c367.02%2c327.461%2c250.517%2c367.901%2c168.015C409.965%2c82.199%2c509.932%2c22.044%2c511.324%2c-73.517C512.741%2c-170.82%2c450.566%2c-263.593%2c375.083%2c-325.011C304.256%2c-382.64%2c206.716%2c-384.517%2c116.028%2c-395.156C38.778%2c-404.218%2c-38.97%2c-408.341%2c-112.217%2c-382.177C-182.863%2c-356.942%2c-230.483%2c-297.342%2c-289.048%2c-250.461C-362.434%2c-191.717%2c-469.065%2c-160.683%2c-499.864%2c-71.87C-531.18%2c18.433%2c-501.077%2c125.413%2c-446.638%2c203.973C-395.14%2c278.29%2c-297.632%2c296.946%2c-216.556%2c336.968C-145.302%2c372.141%2c-78.34%2c411.14%2c0%2c424.448' fill='%231c3708'%3e%3c/path%3e%3cpath d='M1440 1228.287C1565.564 1244.674 1702.374 1197.325 1792.267 1108.1390000000001 1877.923 1023.156 1862.205 884.816 1901.262 770.6510000000001 1935.518 670.519 2024.972 582.789 2007.716 478.375 1990.5030000000002 374.222 1892.079 306.735 1813.029 236.76799999999997 1742.874 174.67399999999998 1665.467 124.60300000000001 1576.131 96.37900000000002 1485.358 67.70100000000002 1391.569 60.97800000000001 1297.243 73.81400000000002 1190.097 88.39499999999998 1062.311 89.86200000000002 996.0550000000001 175.32 929.694 260.912 977.76 384.6 972.4200000000001 492.772 967.663 589.137 936.971 684.403 966.386 776.292 997.838 874.5450000000001 1067.6190000000001 952.0830000000001 1142.25 1023.308 1231.221 1108.2179999999998 1318.048 1212.3719999999998 1440 1228.287' fill='%233a7310'%3e%3c/path%3e%3c/g%3e%3cdefs%3e%3cmask id='SvgjsMask1054'%3e%3crect width='1440' height='560' fill='white'%3e%3c/rect%3e%3c/mask%3e%3c/defs%3e%3c/svg%3e");
			background-repeat: repeat;
            font-family: 'Inter', sans-serif;
            color: white;
        }

        .card {
            background: rgba( 255, 255, 255, 0.25 );
            box-shadow: 0 8px 32px 0 rgba( 31, 38, 135, 0.37 );
            backdrop-filter: blur( 4px );
            -webkit-backdrop-filter: blur( 4px );
            border-radius: 10px;
            border: 1px solid rgba( 255, 255, 255, 0.18 );
        }

        @media only screen and (min-width: 1px) {
            .card { 
                width: 80%;
                margin: auto;
                padding: 10px;
            }
        }

        @media only screen and (min-width: 786px) {
            .card { 
                width: 60%;
                margin: auto;
                padding: 10px;
            }
        }

        @media only screen and (min-width: 1170px) {
            .card { 
                width: 40%;
                margin: auto;
                padding: 10px;
            }
        }

        @media only screen and (min-width: 1440px) {
            .card { 
                width: 30%;
                margin: auto;
                padding: 10px;
            }
        }

        a:link, a:visited {
            color: #60bfeb;
            text-decoration: none;
            cursor: pointer;
        }

        a:link:active, a:visited:active, a:hover {
            color: #89d0f0;
            cursor: pointer;
        }

        #on {
            color: rgb(185, 241, 31);
            font-size: 24px;
        }

        #off {
            color: rgb(206, 32, 32);
            font-size: 24px;
        }

		#man {
            color: #ef8426;
            font-size: 24px;
        }

    </style>

    <script>
		
        var VanillaTilt = (function () {
        'use strict';

        /**
         * Created by Sergiu Șandor (micku7zu) on 1/27/2017.
         * Original idea: https://github.com/gijsroge/tilt.js
         * MIT License.
         * Version 1.7.1
         */

        class VanillaTilt {
        constructor(element, settings = {}) {
            if (!(element instanceof Node)) {
            throw ("Can't initialize VanillaTilt because " + element + " is not a Node.");
            }

            this.width = null;
            this.height = null;
            this.clientWidth = null;
            this.clientHeight = null;
            this.left = null;
            this.top = null;

            // for Gyroscope sampling
            this.gammazero = null;
            this.betazero = null;
            this.lastgammazero = null;
            this.lastbetazero = null;

            this.transitionTimeout = null;
            this.updateCall = null;
            this.event = null;

            this.updateBind = this.update.bind(this);
            this.resetBind = this.reset.bind(this);

            this.element = element;
            this.settings = this.extendSettings(settings);

            this.reverse = this.settings.reverse ? -1 : 1;
            this.glare = VanillaTilt.isSettingTrue(this.settings.glare);
            this.glarePrerender = VanillaTilt.isSettingTrue(this.settings["glare-prerender"]);
            this.fullPageListening = VanillaTilt.isSettingTrue(this.settings["full-page-listening"]);
            this.gyroscope = VanillaTilt.isSettingTrue(this.settings.gyroscope);
            this.gyroscopeSamples = this.settings.gyroscopeSamples;

            this.elementListener = this.getElementListener();

            if (this.glare) {
            this.prepareGlare();
            }

            if (this.fullPageListening) {
            this.updateClientSize();
            }

            this.addEventListeners();
            this.updateInitialPosition();
        }

        static isSettingTrue(setting) {
            return setting === "" || setting === true || setting === 1;
        }

        /**
         * Method returns element what will be listen mouse events
         * @return {Node}
         */
        getElementListener() {
            if (this.fullPageListening) {
            return window.document;
            }

            if (typeof this.settings["mouse-event-element"] === "string") {
            const mouseEventElement = document.querySelector(this.settings["mouse-event-element"]);

            if (mouseEventElement) {
                return mouseEventElement;
            }
            }

            if (this.settings["mouse-event-element"] instanceof Node) {
            return this.settings["mouse-event-element"];
            }

            return this.element;
        }

        /**
         * Method set listen methods for this.elementListener
         * @return {Node}
         */
        addEventListeners() {
            this.onMouseEnterBind = this.onMouseEnter.bind(this);
            this.onMouseMoveBind = this.onMouseMove.bind(this);
            this.onMouseLeaveBind = this.onMouseLeave.bind(this);
            this.onWindowResizeBind = this.onWindowResize.bind(this);
            this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);

            this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
            this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);
            this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);

            if (this.glare || this.fullPageListening) {
            window.addEventListener("resize", this.onWindowResizeBind);
            }

            if (this.gyroscope) {
            window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
            }
        }

        /**
         * Method remove event listeners from current this.elementListener
         */
        removeEventListeners() {
            this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
            this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);
            this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);

            if (this.gyroscope) {
            window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
            }

            if (this.glare || this.fullPageListening) {
            window.removeEventListener("resize", this.onWindowResizeBind);
            }
        }

        destroy() {
            clearTimeout(this.transitionTimeout);
            if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
            }

            this.reset();

            this.removeEventListeners();
            this.element.vanillaTilt = null;
            delete this.element.vanillaTilt;

            this.element = null;
        }

        onDeviceOrientation(event) {
            if (event.gamma === null || event.beta === null) {
            return;
            }

            this.updateElementPosition();

            if (this.gyroscopeSamples > 0) {
            this.lastgammazero = this.gammazero;
            this.lastbetazero = this.betazero;

            if (this.gammazero === null) {
                this.gammazero = event.gamma;
                this.betazero = event.beta;
            } else {
                this.gammazero = (event.gamma + this.lastgammazero) / 2;
                this.betazero = (event.beta + this.lastbetazero) / 2;
            }

            this.gyroscopeSamples -= 1;
            }

            const totalAngleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
            const totalAngleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;

            const degreesPerPixelX = totalAngleX / this.width;
            const degreesPerPixelY = totalAngleY / this.height;

            const angleX = event.gamma - (this.settings.gyroscopeMinAngleX + this.gammazero);
            const angleY = event.beta - (this.settings.gyroscopeMinAngleY + this.betazero);

            const posX = angleX / degreesPerPixelX;
            const posY = angleY / degreesPerPixelY;

            if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
            }

            this.event = {
            clientX: posX + this.left,
            clientY: posY + this.top,
            };

            this.updateCall = requestAnimationFrame(this.updateBind);
        }

        onMouseEnter() {
            this.updateElementPosition();
            this.element.style.willChange = "transform";
            this.setTransition();
        }

        onMouseMove(event) {
            if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
            }

            this.event = event;
            this.updateCall = requestAnimationFrame(this.updateBind);
        }

        onMouseLeave() {
            this.setTransition();

            if (this.settings.reset) {
            requestAnimationFrame(this.resetBind);
            }
        }

        reset() {
            this.event = {
            clientX: this.left + this.width / 2,
            clientY: this.top + this.height / 2
            };

            if (this.element && this.element.style) {
            this.element.style.transform = `perspective(${this.settings.perspective}px) ` +
                `rotateX(0deg) ` +
                `rotateY(0deg) ` +
                `scale3d(1, 1, 1)`;
            }

            this.resetGlare();
        }

        resetGlare() {
            if (this.glare) {
            this.glareElement.style.transform = "rotate(180deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "0";
            }
        }

        updateInitialPosition() {
            if (this.settings.startX === 0 && this.settings.startY === 0) {
            return;
            }

            this.onMouseEnter();

            if (this.fullPageListening) {
            this.event = {
                clientX: (this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.clientWidth,
                clientY: (this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.clientHeight
            };
            } else {
            this.event = {
                clientX: this.left + ((this.settings.startX + this.settings.max) / (2 * this.settings.max) * this.width),
                clientY: this.top + ((this.settings.startY + this.settings.max) / (2 * this.settings.max) * this.height)
            };
            }


            let backupScale = this.settings.scale;
            this.settings.scale = 1;
            this.update();
            this.settings.scale = backupScale;
            this.resetGlare();
        }

        getValues() {
            let x, y;

            if (this.fullPageListening) {
            x = this.event.clientX / this.clientWidth;
            y = this.event.clientY / this.clientHeight;
            } else {
            x = (this.event.clientX - this.left) / this.width;
            y = (this.event.clientY - this.top) / this.height;
            }

            x = Math.min(Math.max(x, 0), 1);
            y = Math.min(Math.max(y, 0), 1);

            let tiltX = (this.reverse * (this.settings.max - x * this.settings.max * 2)).toFixed(2);
            let tiltY = (this.reverse * (y * this.settings.max * 2 - this.settings.max)).toFixed(2);
            let angle = Math.atan2(this.event.clientX - (this.left + this.width / 2), -(this.event.clientY - (this.top + this.height / 2))) * (180 / Math.PI);

            return {
            tiltX: tiltX,
            tiltY: tiltY,
            percentageX: x * 100,
            percentageY: y * 100,
            angle: angle
            };
        }

        updateElementPosition() {
            let rect = this.element.getBoundingClientRect();

            this.width = this.element.offsetWidth;
            this.height = this.element.offsetHeight;
            this.left = rect.left;
            this.top = rect.top;
        }

        update() {
            let values = this.getValues();

            this.element.style.transform = "perspective(" + this.settings.perspective + "px) " +
            "rotateX(" + (this.settings.axis === "x" ? 0 : values.tiltY) + "deg) " +
            "rotateY(" + (this.settings.axis === "y" ? 0 : values.tiltX) + "deg) " +
            "scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")";

            if (this.glare) {
            this.glareElement.style.transform = `rotate(${values.angle}deg) translate(-50%, -50%)`;
            this.glareElement.style.opacity = `${values.percentageY * this.settings["max-glare"] / 100}`;
            }

            this.element.dispatchEvent(new CustomEvent("tiltChange", {
            "detail": values
            }));

            this.updateCall = null;
        }

        /**
         * Appends the glare element (if glarePrerender equals false)
         * and sets the default style
         */
        prepareGlare() {
            // If option pre-render is enabled we assume all html/css is present for an optimal glare effect.
            if (!this.glarePrerender) {
            // Create glare element
            const jsTiltGlare = document.createElement("div");
            jsTiltGlare.classList.add("js-tilt-glare");

            const jsTiltGlareInner = document.createElement("div");
            jsTiltGlareInner.classList.add("js-tilt-glare-inner");

            jsTiltGlare.appendChild(jsTiltGlareInner);
            this.element.appendChild(jsTiltGlare);
            }

            this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
            this.glareElement = this.element.querySelector(".js-tilt-glare-inner");

            if (this.glarePrerender) {
            return;
            }

            Object.assign(this.glareElementWrapper.style, {
            "position": "absolute",
            "top": "0",
            "left": "0",
            "width": "100%",
            "height": "100%",
            "overflow": "hidden",
            "pointer-events": "none"
            });

            Object.assign(this.glareElement.style, {
            "position": "absolute",
            "top": "50%",
            "left": "50%",
            "pointer-events": "none",
            "background-image": `linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)`,
            "width": `${this.element.offsetWidth * 2}px`,
            "height": `${this.element.offsetWidth * 2}px`,
            "transform": "rotate(180deg) translate(-50%, -50%)",
            "transform-origin": "0% 0%",
            "opacity": "0",
            });
        }

        updateGlareSize() {
            if (this.glare) {
            Object.assign(this.glareElement.style, {
                "width": `${this.element.offsetWidth * 2}`,
                "height": `${this.element.offsetWidth * 2}`,
            });
            }
        }

        updateClientSize() {
            this.clientWidth = window.innerWidth
            || document.documentElement.clientWidth
            || document.body.clientWidth;

            this.clientHeight = window.innerHeight
            || document.documentElement.clientHeight
            || document.body.clientHeight;
        }

        onWindowResize() {
            this.updateGlareSize();
            this.updateClientSize();
        }

        setTransition() {
            clearTimeout(this.transitionTimeout);
            this.element.style.transition = this.settings.speed + "ms " + this.settings.easing;
            if (this.glare) this.glareElement.style.transition = `opacity ${this.settings.speed}ms ${this.settings.easing}`;

            this.transitionTimeout = setTimeout(() => {
            this.element.style.transition = "";
            if (this.glare) {
                this.glareElement.style.transition = "";
            }
            }, this.settings.speed);

        }

        /**
         * Method return patched settings of instance
         * @param {boolean} settings.reverse - reverse the tilt direction
         * @param {number} settings.max - max tilt rotation (degrees)
         * @param {startX} settings.startX - the starting tilt on the X axis, in degrees. Default: 0
         * @param {startY} settings.startY - the starting tilt on the Y axis, in degrees. Default: 0
         * @param {number} settings.perspective - Transform perspective, the lower the more extreme the tilt gets
         * @param {string} settings.easing - Easing on enter/exit
         * @param {number} settings.scale - 2 = 200%, 1.5 = 150%, etc..
         * @param {number} settings.speed - Speed of the enter/exit transition
         * @param {boolean} settings.transition - Set a transition on enter/exit
         * @param {string|null} settings.axis - What axis should be disabled. Can be X or Y
         * @param {boolean} settings.glare - What axis should be disabled. Can be X or Y
         * @param {number} settings.max-glare - the maximum "glare" opacity (1 = 100%, 0.5 = 50%)
         * @param {boolean} settings.glare-prerender - false = VanillaTilt creates the glare elements for you, otherwise
         * @param {boolean} settings.full-page-listening - If true, parallax effect will listen to mouse move events on the whole document, not only the selected element
         * @param {string|object} settings.mouse-event-element - String selector or link to HTML-element what will be listen mouse events
         * @param {boolean} settings.reset - false = If the tilt effect has to be reset on exit
         * @param {gyroscope} settings.gyroscope - Enable tilting by deviceorientation events
         * @param {gyroscopeSensitivity} settings.gyroscopeSensitivity - Between 0 and 1 - The angle at which max tilt position is reached. 1 = 90deg, 0.5 = 45deg, etc..
         * @param {gyroscopeSamples} settings.gyroscopeSamples - How many gyroscope moves to decide the starting position.
         */
        extendSettings(settings) {
            let defaultSettings = {
            reverse: false,
            max: 15,
            startX: 0,
            startY: 0,
            perspective: 1000,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: 1,
            speed: 300,
            transition: true,
            axis: null,
            glare: false,
            "max-glare": 1,
            "glare-prerender": false,
            "full-page-listening": false,
            "mouse-event-element": null,
            reset: true,
            gyroscope: true,
            gyroscopeMinAngleX: -45,
            gyroscopeMaxAngleX: 45,
            gyroscopeMinAngleY: -45,
            gyroscopeMaxAngleY: 45,
            gyroscopeSamples: 10
            };

            let newSettings = {};
            for (var property in defaultSettings) {
            if (property in settings) {
                newSettings[property] = settings[property];
            } else if (this.element.hasAttribute("data-tilt-" + property)) {
                let attribute = this.element.getAttribute("data-tilt-" + property);
                try {
                newSettings[property] = JSON.parse(attribute);
                } catch (e) {
                newSettings[property] = attribute;
                }

            } else {
                newSettings[property] = defaultSettings[property];
            }
            }

            return newSettings;
        }

        static init(elements, settings) {
            if (elements instanceof Node) {
            elements = [elements];
            }

            if (elements instanceof NodeList) {
            elements = [].slice.call(elements);
            }

            if (!(elements instanceof Array)) {
            return;
            }

            elements.forEach((element) => {
            if (!("vanillaTilt" in element)) {
                element.vanillaTilt = new VanillaTilt(element, settings);
            }
            });
        }
        }

        if (typeof document !== "undefined") {
        /* expose the class to window */
        window.VanillaTilt = VanillaTilt;

        /**
         * Auto load
         */
        VanillaTilt.init(document.querySelectorAll("[data-tilt]"));
        }

        return VanillaTilt;

        }());
    </script>

</head>

<body>

	<div align="center" style="margin: 10px;">
        <img align="center" class="logo" src="https://raw.githubusercontent.com/enzon19/copypastabrbot/main/resources/logo.png" alt="Família Buscapé Bot" width="187" height="187">
    </div>

    <script type="text/javascript" src="vanilla-tilt.js"></script>
    <script type="text/javascript">

        VanillaTilt.init(document.querySelector(".logo"), {
            max: 15,
            speed: 400,
            glare: true,
            "max-glare": 0.2
        });

    </script>

    <div class="card" align="center" style="margin-bottom: 10px;">

        <h2>Introdução</h2>
        <p>O Copypasta Bot funciona através do modo inline, ou seja, ao escrever @copypastabrbot e pesquisar por uma copypasta. <a href="https://github.com/enzon19/copypastabrbot">Qualquer pessoa pode usar o bot, ver o código principal e criar códigos baseados</a>.<p>

    </div>

    <div class="card" align="center" style="margin-bottom: 10px;">

        <h2>Status do Servidor</h2>
        <p align="left"><span id="on">•</span> Estado do Bot<p>
        <hr style="border: 1px solid rgba( 255, 255, 255, 0.18 );">
        <p align="left"><span id="on">•</span> Modo "Inline"<p>
        <hr style="border: 1px solid rgba( 255, 255, 255, 0.18 );">
        <p align="left"><span id="off">•</span> Comandos novos 🤔<p>

    </div>

</body>

</html>
